"""
Integration tests for bulk device editing workflow.

Tests bulk update operations including:
- Single and multiple device updates
- Field validation and resolution
- Interface creation/updates
- Error handling for partial failures
"""

import pytest
from unittest.mock import AsyncMock, Mock, patch
from services.device_update_service import DeviceUpdateService
from tests.fixtures import NAUTOBOT_DEVICE_STANDARD, create_devices_list


# ==============================================================================
# Test Class: Single Device Update
# ==============================================================================

@pytest.mark.integration
@pytest.mark.nautobot
class TestSingleDeviceUpdate:
    """Test updating a single device."""

    @pytest.fixture(autouse=True)
    def setup(self, mock_nautobot_service):
        """Set up test instance."""
        self.service = DeviceUpdateService(mock_nautobot_service)
        self.mock_nautobot = mock_nautobot_service

        # Mock all resolve methods to avoid real API calls
        with patch.object(self.service.common, 'resolve_status_id', return_value='status-uuid'),\
             patch.object(self.service.common, 'resolve_platform_id', return_value='platform-uuid'),\
             patch.object(self.service.common, 'resolve_role_id', return_value='role-uuid'),\
             patch.object(self.service.common, 'resolve_location_id', return_value='location-uuid'),\
             patch.object(self.service.common, 'resolve_device_type_id', return_value='device-type-uuid'),\
             patch.object(self.service.common, 'resolve_namespace_id', return_value='namespace-uuid'):
            yield

    @pytest.mark.asyncio
    async def test_update_device_status(self):
        """Test updating device status."""
        # Arrange
        device = NAUTOBOT_DEVICE_STANDARD.copy()
        self.mock_nautobot.graphql_query = AsyncMock(
            return_value={"data": {"devices": [device]}}
        )

        updated_device = device.copy()
        updated_device["status"] = {"name": "Offline"}
        self.mock_nautobot.rest_request = AsyncMock(return_value=updated_device)

        # Act
        result = await self.service.update_device(
            device_identifier={"name": "test-switch-01"},
            update_data={"status": "offline"}
        )

        # Assert
        assert result["success"] is True
        assert "status" in result["updated_fields"]
        assert result["device_name"] == "test-switch-01"

    @pytest.mark.asyncio
    async def test_update_multiple_fields(self):
        """Test updating multiple device fields at once."""
        # Arrange
        device = NAUTOBOT_DEVICE_STANDARD.copy()
        self.mock_nautobot.graphql_query = AsyncMock(
            return_value={"data": {"devices": [device]}}
        )
        self.mock_nautobot.rest_request = AsyncMock(return_value=device)

        # Act
        result = await self.service.update_device(
            device_identifier={"id": "device-uuid-456"},
            update_data={
                "status": "active",
                "serial": "ABC123",
                "asset_tag": "ASSET-001",
                "tags": ["production", "critical"]
            }
        )

        # Assert
        assert result["success"] is True
        assert len(result["updated_fields"]) >= 3

    @pytest.mark.asyncio
    async def test_update_with_custom_fields(self):
        """Test updating device with custom fields."""
        # Arrange
        device = NAUTOBOT_DEVICE_STANDARD.copy()
        self.mock_nautobot.graphql_query = AsyncMock(
            return_value={"data": {"devices": [device]}}
        )
        self.mock_nautobot.rest_request = AsyncMock(return_value=device)

        # Act
        result = await self.service.update_device(
            device_identifier={"name": "test-switch-01"},
            update_data={
                "custom_fields": {
                    "site_code": "DC1-001",
                    "rack_position": "42"
                }
            }
        )

        # Assert
        assert result["success"] is True
        assert "custom_fields" in result["updated_fields"]


# ==============================================================================
# Test Class: Bulk Device Updates
# ==============================================================================

@pytest.mark.integration
@pytest.mark.nautobot
class TestBulkDeviceUpdates:
    """Test bulk update operations on multiple devices."""

    @pytest.fixture(autouse=True)
    def setup(self, mock_nautobot_service):
        """Set up test instance."""
        self.service = DeviceUpdateService(mock_nautobot_service)
        self.mock_nautobot = mock_nautobot_service

    @pytest.mark.asyncio
    async def test_bulk_update_status(self):
        """Test bulk status update for multiple devices."""
        # Arrange
        devices_data = create_devices_list(count=5)
        self.mock_nautobot.graphql_query = AsyncMock(return_value=devices_data)
        self.mock_nautobot.rest_request = AsyncMock(return_value={"success": True})

        device_ids = [f"device-uuid-{i}" for i in range(1, 6)]

        # Act: Update all devices to "maintenance" status
        results = []
        for device_id in device_ids:
            result = await self.service.update_device(
                device_identifier={"id": device_id},
                update_data={"status": "maintenance"}
            )
            results.append(result)

        # Assert
        assert len(results) == 5
        assert all(r["success"] for r in results)

    @pytest.mark.asyncio
    async def test_bulk_update_with_partial_failures(self):
        """Test bulk update where some devices fail."""
        # Arrange
        devices_data = create_devices_list(count=3)
        self.mock_nautobot.graphql_query = AsyncMock(return_value=devices_data)

        # First succeeds, second fails, third succeeds
        self.mock_nautobot.rest_request = AsyncMock(side_effect=[
            {"success": True, "id": "dev-1"},
            Exception("Device locked for editing"),
            {"success": True, "id": "dev-3"},
        ])

        device_ids = ["dev-1", "dev-2", "dev-3"]

        # Act
        results = []
        for device_id in device_ids:
            try:
                result = await self.service.update_device(
                    device_identifier={"id": device_id},
                    update_data={"status": "active"}
                )
                results.append(result)
            except Exception as e:
                results.append({"success": False, "error": str(e)})

        # Assert
        assert len(results) == 3
        successes = [r for r in results if r.get("success")]
        failures = [r for r in results if not r.get("success")]
        assert len(successes) == 2
        assert len(failures) == 1

    @pytest.mark.asyncio
    async def test_bulk_tag_assignment(self):
        """Test assigning tags to multiple devices."""
        # Arrange
        devices_data = create_devices_list(count=3)
        self.mock_nautobot.graphql_query = AsyncMock(return_value=devices_data)
        self.mock_nautobot.rest_request = AsyncMock(return_value={"success": True})

        # Act: Assign "production" tag to all devices
        results = []
        for i in range(1, 4):
            result = await self.service.update_device(
                device_identifier={"id": f"device-uuid-{i}"},
                update_data={"tags": ["production"]}
            )
            results.append(result)

        # Assert
        assert all(r["success"] for r in results)


# ==============================================================================
# Test Class: Field Resolution
# ==============================================================================

@pytest.mark.integration
@pytest.mark.nautobot
class TestFieldResolution:
    """Test resolution of field names to UUIDs."""

    @pytest.fixture(autouse=True)
    def setup(self, mock_nautobot_service):
        """Set up test instance."""
        self.service = DeviceUpdateService(mock_nautobot_service)
        self.mock_nautobot = mock_nautobot_service

    @pytest.mark.asyncio
    async def test_resolves_platform_name_to_uuid(self):
        """Test that platform name is resolved to UUID."""
        # Arrange
        device = NAUTOBOT_DEVICE_STANDARD.copy()
        self.mock_nautobot.graphql_query = AsyncMock(side_effect=[
            {"data": {"devices": [device]}},  # Device query
            {"data": {"platforms": [{"id": "platform-uuid", "name": "cisco_ios"}]}}  # Platform query
        ])
        self.mock_nautobot.rest_request = AsyncMock(return_value=device)

        # Act
        result = await self.service.update_device(
            device_identifier={"id": "device-uuid-456"},
            update_data={"platform": "cisco_ios"}  # Name, not UUID
        )

        # Assert
        assert result["success"] is True
        # Verify platform was resolved and used
        patch_call = [
            call for call in self.mock_nautobot.rest_request.call_args_list
            if call[1].get("method") == "PATCH"
        ]
        assert len(patch_call) >= 1

    @pytest.mark.asyncio
    async def test_resolves_location_name_to_uuid(self):
        """Test that location name is resolved to UUID."""
        # Arrange
        device = NAUTOBOT_DEVICE_STANDARD.copy()
        self.mock_nautobot.graphql_query = AsyncMock(side_effect=[
            {"data": {"devices": [device]}},
            {"data": {"locations": [{"id": "loc-uuid", "name": "DC2"}]}}
        ])
        self.mock_nautobot.rest_request = AsyncMock(return_value=device)

        # Act
        result = await self.service.update_device(
            device_identifier={"name": "test-switch-01"},
            update_data={"location": "DC2"}
        )

        # Assert
        assert result["success"] is True


# ==============================================================================
# Test Class: Interface Updates
# ==============================================================================

@pytest.mark.integration
@pytest.mark.nautobot
class TestInterfaceUpdates:
    """Test interface creation/updates during device updates."""

    @pytest.fixture(autouse=True)
    def setup(self, mock_nautobot_service):
        """Set up test instance."""
        self.service = DeviceUpdateService(mock_nautobot_service)
        self.mock_nautobot = mock_nautobot_service

    @pytest.mark.asyncio
    async def test_updates_primary_ip_with_interface_creation(self):
        """Test updating primary IP with automatic interface creation."""
        # Arrange
        device = NAUTOBOT_DEVICE_STANDARD.copy()
        self.mock_nautobot.graphql_query = AsyncMock(
            return_value={"data": {"devices": [device]}}
        )

        # Mock IP and interface creation
        self.mock_nautobot.rest_request = AsyncMock(side_effect=[
            {"id": "ip-uuid", "address": "10.0.0.5/32"},  # IP creation
            {"id": "int-uuid", "name": "Loopback0"},       # Interface creation
            {"id": "assign-uuid"},                          # IP assignment
            device  # Device PATCH
        ])

        # Act
        result = await self.service.update_device(
            device_identifier={"id": "device-uuid-456"},
            update_data={"primary_ip4": "10.0.0.5/32"},
            interface_config={"name": "Loopback0", "type": "virtual"}
        )

        # Assert
        assert result["success"] is True


# ==============================================================================
# Test Class: Device Identification
# ==============================================================================

@pytest.mark.integration
@pytest.mark.nautobot
class TestDeviceIdentification:
    """Test various methods of identifying devices for update."""

    @pytest.fixture(autouse=True)
    def setup(self, mock_nautobot_service):
        """Set up test instance."""
        self.service = DeviceUpdateService(mock_nautobot_service)
        self.mock_nautobot = mock_nautobot_service

    @pytest.mark.asyncio
    async def test_identify_device_by_uuid(self):
        """Test identifying device by UUID."""
        # Arrange
        device = NAUTOBOT_DEVICE_STANDARD.copy()
        self.mock_nautobot.graphql_query = AsyncMock(
            return_value={"data": {"devices": [device]}}
        )
        self.mock_nautobot.rest_request = AsyncMock(return_value=device)

        # Act
        result = await self.service.update_device(
            device_identifier={"id": "device-uuid-456"},
            update_data={"status": "active"}
        )

        # Assert
        assert result["success"] is True
        assert result["device_id"] == "device-uuid-456"

    @pytest.mark.asyncio
    async def test_identify_device_by_name(self):
        """Test identifying device by name."""
        # Arrange
        device = NAUTOBOT_DEVICE_STANDARD.copy()
        self.mock_nautobot.graphql_query = AsyncMock(
            return_value={"data": {"devices": [device]}}
        )
        self.mock_nautobot.rest_request = AsyncMock(return_value=device)

        # Act
        result = await self.service.update_device(
            device_identifier={"name": "test-switch-01"},
            update_data={"status": "active"}
        )

        # Assert
        assert result["success"] is True
        assert result["device_name"] == "test-switch-01"

    @pytest.mark.asyncio
    async def test_identify_device_by_ip_address(self):
        """Test identifying device by IP address."""
        # Arrange
        device = NAUTOBOT_DEVICE_STANDARD.copy()
        self.mock_nautobot.graphql_query = AsyncMock(
            return_value={"data": {"devices": [device]}}
        )
        self.mock_nautobot.rest_request = AsyncMock(return_value=device)

        # Act
        result = await self.service.update_device(
            device_identifier={"ip_address": "10.0.0.1"},
            update_data={"status": "active"}
        )

        # Assert
        assert result["success"] is True


# ==============================================================================
# Test Class: Error Handling
# ==============================================================================

@pytest.mark.integration
@pytest.mark.nautobot
class TestBulkEditErrorHandling:
    """Test error handling in bulk edit operations."""

    @pytest.fixture(autouse=True)
    def setup(self, mock_nautobot_service):
        """Set up test instance."""
        self.service = DeviceUpdateService(mock_nautobot_service)
        self.mock_nautobot = mock_nautobot_service

    @pytest.mark.asyncio
    async def test_handles_device_not_found(self):
        """Test handling when device doesn't exist."""
        # Arrange
        self.mock_nautobot.graphql_query = AsyncMock(
            return_value={"data": {"devices": []}}  # No device found
        )

        # Act
        result = await self.service.update_device(
            device_identifier={"name": "non-existent"},
            update_data={"status": "active"},
            create_if_missing=False
        )

        # Assert
        assert result["success"] is False
        assert "not found" in result["message"].lower()

    @pytest.mark.asyncio
    async def test_handles_invalid_field_value(self):
        """Test handling invalid field values."""
        # Arrange
        device = NAUTOBOT_DEVICE_STANDARD.copy()
        self.mock_nautobot.graphql_query = AsyncMock(
            return_value={"data": {"devices": [device]}}
        )
        self.mock_nautobot.rest_request = AsyncMock(
            side_effect=Exception("Invalid status value: 'invalid-status'")
        )

        # Act
        result = await self.service.update_device(
            device_identifier={"id": "device-uuid-456"},
            update_data={"status": "invalid-status"}
        )

        # Assert
        assert result["success"] is False
        assert "warnings" in result or "error" in result["message"].lower()

    @pytest.mark.asyncio
    async def test_provides_validation_warnings(self):
        """Test that validation warnings are provided."""
        # Arrange
        device = NAUTOBOT_DEVICE_STANDARD.copy()
        self.mock_nautobot.graphql_query = AsyncMock(
            return_value={"data": {"devices": [device]}}
        )
        self.mock_nautobot.rest_request = AsyncMock(return_value=device)

        # Act: Try to update with potentially problematic data
        result = await self.service.update_device(
            device_identifier={"id": "device-uuid-456"},
            update_data={"serial": ""}  # Empty serial
        )

        # Assert
        # Should still succeed but may have warnings
        assert "warnings" in result or "success" in result
